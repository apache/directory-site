Title: 14 - Extended Operations
NavPrev: 13-controls.html
NavPrevText: 13 - Controls
NavUp: ../internal-design-guide.html
NavUpText: Internal Design Guide
NavNext: 15-ldif.html
NavNextText: 15 - LDIF
Notice: Licensed to the Apache Software Foundation (ASF) under one
    or more contributor license agreements.  See the NOTICE file
    distributed with this work for additional information
    regarding copyright ownership.  The ASF licenses this file
    to you under the Apache License, Version 2.0 (the
    "License"); you may not use this file except in compliance
    with the License.  You may obtain a copy of the License at
    .
    http://www.apache.org/licenses/LICENSE-2.0
    .
    Unless required by applicable law or agreed to in writing,
    software distributed under the License is distributed on an
    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, either express or implied.  See the License for the
    specific language governing permissions and limitations
    under the License.

# 14 - Extended Operations

**Extended Operation** is a **LDAP** message which may content a payload. It is generally sent by the clinet, but the server can send a _ExtendedResponse_ as a response to any operation : the **Notice of Disconnection**. 

Here is the syntax for the extended Operation :

    :::Text
    ExtendedRequest ::= [APPLICATION 23] SEQUENCE {
        requestName      [0] LDAPOID,
        requestValue     [1] OCTET STRING OPTIONAL }

    ExtendedResponse ::= [APPLICATION 24] SEQUENCE {
        COMPONENTS OF LDAPResult,
        responseName     [10] LDAPOID OPTIONAL,
        responseValue    [11] OCTET STRING OPTIONAL }

(the payload is the _requestValue_ or _responseValue_ part, which may be **BER** encoded).

This message is routinely decoded as is by the standard **LDAP** message decoder, but the payload has to be decoded on its own. 

## Supported extended operations

Currently, the **LDAP API** support the following extended operations :

* _Cancel_ request and response ([RFC 3909](https://tools.ietf.org/html/rfc3909))
* _CertGenerationRequest_ request and response, an **ApacheDS** specific operation in charge of generating a certificate
* _GracefulDisconnect_ response,  an **ApacheDS** specific operation used when the server is shutdown properly
* _GracefulShutdown_ request and response, an **ApacheDS** specific operation used to shutdown the remote server properly
* _PasswordModify_ request and response ([RFC 3062](https://tools.ietf.org/html/rfc3062))
* _StartTls_ request and response ([RFC 4511](https://tools.ietf.org/html/rfc4511))
* _StoredProcedure_ request and response, an **ApacheDS** specific operation used to execute a stored procedure on the server
* _WhoAmI_ request and response ([RFC 4532](https://tools.ietf.org/html/rfc4532))


## Encoding and decoding

When the _requestValue_ part is present, it has to be encoded (when the client sends the request to the srrver) or decoded ( when the client receives the response from the server).

### Decoding a request

The payload is decoded on the fly when the request is processed during the _extendedRequest_ is being decoded. The _StoreExtendedRequestValue_ will store the _byte[]_ - if any - and depending on the operation, the specific request will decode the value. Here is the _action_ method for the _StoreExtendedRequestValue_ class :


    :::Java
    public void action( LdapMessageContainer<ExtendedRequestDecorator<?>> container ) throws DecoderException
    {
        // We can allocate the ExtendedRequest Object
        ExtendedRequestDecorator<?> extendedRequest = container.getMessage();

        // Get the Value and store it in the ExtendedRequest
        TLV tlv = container.getCurrentTLV();

        // We have to handle the special case of a 0 length matched
        // value
        if ( tlv.getLength() == 0 )
        {
            extendedRequest.setRequestValue( Strings.EMPTY_BYTES );
        }
        else
        {
            extendedRequest.setRequestValue( tlv.getValue().getData() );
        }

Each implementaion may have a _setRequestValue_ methd, overloading the parentclass. In this case, the value is decoded by the method.

Here is an example of _setRequestValue_ implementation (for the _PasswordModifyRequest_ class) :

    :::Java
    public void setRequestValue( byte[] requestValue )
    {
        PasswordModifyRequestDecoder decoder = new PasswordModifyRequestDecoder();

        try
        {
            if ( requestValue != null )
            {
                passwordModifyRequest = decoder.decode( requestValue );

                this.requestValue = new byte[requestValue.length];
                System.arraycopy( requestValue, 0, this.requestValue, 0, requestValue.length );
            }
            else
            {
                this.requestValue = null;
            }
        }
        catch ( DecoderException e )
        {
            LOG.error( I18n.err( I18n.ERR_04165 ), e );
            throw new RuntimeException( e );
        }
    }

As we can see, the decoder is invoked if the _requestValye_ bytes is not null. It instanciate a _PasswordModifyRequest_.

If there is no payload, the parent's method is invoked (which basically does nothing).

Here is a schema showing which operation as a payload that needs to be decoded :

![Extended Operations Payload](images/extended-request-decorator.png)
