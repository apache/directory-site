<!DOCTYPE html>

<html lang="en">
<head>
    <title>14 - Extended Operations &mdash; Apache Directory</title>

    <link href="/css/common.css" rel="stylesheet" type="text/css"/>
    <link href="/css/brown.css" rel="stylesheet" type="text/css"/>

    <link rel="shortcut icon" href="/images/api-icon_16x16.png">
</head>
<body>
<div id="container">
    <div id="header">
    <div id="subProjectsNavBar">
        <a href="/">
             
                Main
            
        </a>
        &nbsp;|&nbsp;
        <a href="/apacheds/">
             
                ApacheDS
            
        </a>
        &nbsp;|&nbsp;
        <a href="/studio/">
             
                Studio
            
        </a>
        &nbsp;|&nbsp;
        <a href="/api/">
            
                <strong>LDAP API</strong>
            
        </a>
        &nbsp;|&nbsp;
        <a href="/mavibot/">
             
                Mavibot
            
        </a>
        &nbsp;|&nbsp;
        <a href="/scimple/">
             
                SCIMple
            
        </a>
        &nbsp;|&nbsp;
        <a href="/fortress/">
             
                Fortress
            
        </a>
        &nbsp;|&nbsp;
        <a href="/kerby/">
             
                Kerby
            
        </a>
    </div>
</div>


    <div id="content">
        <div id="leftColumn">
            <div id="navigation">
                
                <h5>LDAP API </h5>
                <ul>
                    <li><a href="/api/">Home</a></li>
                    <li><a href="/api/news.html">News</a></li>
                </ul>

                <h5>Downloads</h5>
                <ul>
                    <li><a href="/api/downloads-1.html">Version 1.0.3</a>&nbsp;&nbsp;<img src="/images/new_badge.gif" alt="" style="margin-bottom:-3px;" border="0"></li>
                    <li><a href="/api/downloads-2.html">Version 2.0.1</a>&nbsp;&nbsp;<img src="/images/new_badge.gif" alt="" style="margin-bottom:-3px;" border="0"></li>
                    <li><a href="/api/download-old-versions.html">Older versions</a></li>
                </ul>

                <h5>Getting Started</h5>
                <ul>
                    <li><a href="/api/vision.html">Vision</a></li>
                    <li><a href="/api/java-api.html">Java API</a></li>
                </ul>

                <h5>Documentation</h5>
                <ul>
                    <li><a href="/api/five-minutes-tutorial.html">Five minute tutorial</a></li>
                    <li><a href="/api/user-guide.html">User Guide</a></li>
                    <li><a href="/api/migration-guide.html">API 1 to 2 migration</a></li>
                    <li><a href="/api/gen-docs/latest/apidocs/">JavaDocs</a></li>
                    <li><a href="/api/gen-docs/latest2/apidocs/">JavaDocs 2</a></li>
                    <li><a href="/api/gen-docs/latest/xref/">Cross-Reference</a></li>
                    <li><a href="/api/gen-docs/latest2/xref/">Cross-Reference 2</a></li>
                    
                    <li><a href="/api/developer-guide.html">Developer Guide</a></li>
                    <li><a href="/api/internal-design-guide.html">Internal Guide</a></li>
                </ul>

                <h5>Support</h5>
<ul>
    <li><a href="/mailing-lists-and-irc.html">Mailing Lists &amp; IRC</a></li>
    <li><a href="/sources.html">Sources</a></li>
    <li><a href="/issue-tracking.html">Issue Tracking</a></li>
    <li><a href="/commercial-support.html">Commercial Support</a></li>
</ul>

<h5>Community</h5>
<ul>
    <li><a href="/contribute.html">How to Contribute</a></li>
    <li><a href="/team.html">Team</a></li>
    <li><a href="/original-project-proposal.html">Original Project Proposal</a></li>
    <li><a href="/special-thanks.html" class="external-link" rel="nofollow">Special Thanks</a></li>
</ul>

<h5>About Apache</h5>
<ul>
    <li><a href="http://www.apache.org/">Apache</a></li>
    <li><a href="http://www.apache.org/licenses/">License</a></li>
    <li><a href="http://www.apache.org/foundation/sponsorship.html">Sponsorship</a></li>
    <li><a href="http://www.apache.org/foundation/thanks.html">Thanks</a></li>
    <li><a href="http://www.apache.org/security/">Security</a></li>
</ul>

            </div>
        </div>
        <div id="rightColumn">
            
    <div class="nav">
        <div class="nav_prev">
            
                
                <a href="13-controls.html">13 - Controls</a>
            
        </div>
        <div class="nav_up">
            
                
                <a href="../internal-design-guide.html">Internal Design Guide</a>
            
        </div>
        <div class="nav_next">
            
                
                <a href="15-ldif.html">15 - LDIF</a>
            
        </div>
        <div class="clearfix"></div>
    </div>


            
	<h1 id="14---extended-operations">14 - Extended Operations</h1>
<p><strong>Extended Operation</strong> is a <strong>LDAP</strong> message which may content a payload. It is generally sent by the clinet, but the server can send a <em>ExtendedResponse</em> as a response to any operation : the <strong>Notice of Disconnection</strong>.</p>
<p>Here is the syntax for the extended Operation :</p>
<pre><code>ExtendedRequest ::= [APPLICATION 23] SEQUENCE {
    requestName      [0] LDAPOID,
    requestValue     [1] OCTET STRING OPTIONAL }

ExtendedResponse ::= [APPLICATION 24] SEQUENCE {
    COMPONENTS OF LDAPResult,
    responseName     [10] LDAPOID OPTIONAL,
    responseValue    [11] OCTET STRING OPTIONAL }
</code></pre>
<p>(the payload is the <em>requestValue</em> or <em>responseValue</em> part, which may be <strong>BER</strong> encoded).</p>
<p>This message is routinely decoded as is by the standard <strong>LDAP</strong> message decoder, but the payload has to be decoded on its own.</p>
<h2 id="supported-extended-operations">Supported extended operations</h2>
<p>Currently, the <strong>LDAP API</strong> support the following extended operations :</p>
<ul>
<li><em>Cancel</em> request and response (<a href="https://tools.ietf.org/html/rfc3909">RFC 3909</a>)</li>
<li><em>CertGenerationRequest</em> request and response, an <strong>ApacheDS</strong> specific operation in charge of generating a certificate</li>
<li><em>GracefulDisconnect</em> response,  an <strong>ApacheDS</strong> specific operation used when the server is shutdown properly</li>
<li><em>GracefulShutdown</em> request and response, an <strong>ApacheDS</strong> specific operation used to shutdown the remote server properly</li>
<li><em>PasswordModify</em> request and response (<a href="https://tools.ietf.org/html/rfc3062">RFC 3062</a>)</li>
<li><em>StartTls</em> request and response (<a href="https://tools.ietf.org/html/rfc4511">RFC 4511</a>)</li>
<li><em>StoredProcedure</em> request and response, an <strong>ApacheDS</strong> specific operation used to execute a stored procedure on the server</li>
<li><em>WhoAmI</em> request and response (<a href="https://tools.ietf.org/html/rfc4532">RFC 4532</a>)</li>
</ul>
<h2 id="encoding-and-decoding">Encoding and decoding</h2>
<p>When the <em>requestValue</em> part is present, it has to be encoded (when the client sends the request to the srrver) or decoded ( when the client receives the response from the server).</p>
<h3 id="decoding-a-requestresponse">Decoding a request/response</h3>
<p>The payload is decoded on the fly when the request/response is processed during the <em>extendedRequest</em>/<em>extendedResponse</em> is being decoded. The <em>StoreExtendedRequestValue</em>/<em>StoreExtendedResponseValue</em> will store the <em>byte[]</em> - if any - and depending on the operation, the specific request/response will decode the value. Here is the <em>action</em> method for the <em>StoreExtendedRequestValue</em> class :</p>
<pre><code>:::Java
public void action( LdapMessageContainer&lt;ExtendedRequestDecorator&lt;?&gt;&gt; container ) throws DecoderException
{
    // We can allocate the ExtendedRequest Object
    ExtendedRequestDecorator&lt;?&gt; extendedRequest = container.getMessage();

    // Get the Value and store it in the ExtendedRequest
    TLV tlv = container.getCurrentTLV();

    // We have to handle the special case of a 0 length matched
    // value
    if ( tlv.getLength() == 0 )
    {
        extendedRequest.setRequestValue( Strings.EMPTY_BYTES );
    }
    else
    {
        extendedRequest.setRequestValue( tlv.getValue().getData() );
    }
</code></pre>
<p>Each implementaion may have a <em>setRequestValue</em>/<em>setResponseValue</em> methd, overloading the parentclass. In this case, the value is decoded by the method.</p>
<p>Here is an example of <em>setRequestValue</em> implementation (for the <em>PasswordModifyRequest</em> class) :</p>
<pre><code>:::Java
public void setRequestValue( byte[] requestValue )
{
    PasswordModifyRequestDecoder decoder = new PasswordModifyRequestDecoder();

    try
    {
        if ( requestValue != null )
        {
            passwordModifyRequest = decoder.decode( requestValue );

            this.requestValue = new byte[requestValue.length];
            System.arraycopy( requestValue, 0, this.requestValue, 0, requestValue.length );
        }
        else
        {
            this.requestValue = null;
        }
    }
    catch ( DecoderException e )
    {
        LOG.error( I18n.err( I18n.ERR_04165 ), e );
        throw new RuntimeException( e );
    }
}
</code></pre>
<p>As we can see, the decoder is invoked if the <em>requestValue</em> bytes is not null. It instanciate a <em>PasswordModifyRequest</em>.</p>
<p>If there is no payload, the parent&rsquo;s method is invoked (which basically does nothing).</p>
<p>Here is a schema showing which request/response operations as a payload that needs to be decoded :</p>
<p><img src="images/extended-request-decorator.png" alt="Extended Operations Payload"></p>
<h3 id="encoding-a-requestresponse">Encoding a request/response</h3>
<p>Encoding is done through a <em>Decorator</em>. Each extended operation has a dedicated <em>Decorator</em>, which may have a specific encoding function. Again, as we only encode the payload, if this payload is absent, there is nothing to encode. Not all the extended operations have a payload.</p>
<p>If there is a payload to encode, this is done by calling the <em>getRequestValue()</em>/<em>getResponseValue()</em> method in the decorator. Here is an example :</p>
<pre><code>:::Java
public byte[] getRequestValue()
{
    if ( requestValue == null )
    {
        try
        {
            requestValue = encodeInternal().array();
        }
        catch ( EncoderException e )
        {
            LOG.error( I18n.err( I18n.ERR_04167 ), e );
            throw new RuntimeException( e );
        }
    }

    return requestValue;
}
</code></pre>
<p>The <em>encodeInternal</em> method is in charge of encoding teh paylod.</p>
<p>If the <em>getRequestValue</em>/getResponseValue_ method is absent, that leans there is nothing to encode. The inherited method will be executed, which returns null.</p>
<p>Internally, we compute the length of the needed <strong>PDU</strong> accordingly to the data we have to encode, allocate a <em>ByteBuffer</em> to hold the encoded data, and store teh encoded data into it :</p>
<pre><code>:::Java
/**
 * Encodes the PasswordModifyRequest extended operation.
 * 
 * @return A ByteBuffer that contains the encoded PDU
 * @throws org.apache.directory.api.asn1.EncoderException If anything goes wrong.
 */
/* No qualifier */ByteBuffer encodeInternal() throws EncoderException
{
    ByteBuffer bb = ByteBuffer.allocate( computeLengthInternal() );

    bb.put( UniversalTag.SEQUENCE.getValue() );
    bb.put( TLV.getBytes( requestLength ) );

    if ( passwordModifyRequest.getUserIdentity() != null )
    {
        byte[] userIdentity = passwordModifyRequest.getUserIdentity();
        bb.put( ( byte ) PasswordModifyRequestConstants.USER_IDENTITY_TAG );
        bb.put( TLV.getBytes( userIdentity.length ) );
        bb.put( userIdentity );
    }

    if ( passwordModifyRequest.getOldPassword() != null )
    {
        byte[] oldPassword = passwordModifyRequest.getOldPassword();
        bb.put( ( byte ) PasswordModifyRequestConstants.OLD_PASSWORD_TAG );
        bb.put( TLV.getBytes( oldPassword.length ) );
        bb.put( oldPassword );
    }

    if ( passwordModifyRequest.getNewPassword() != null )
    {
        byte[] newPassword = passwordModifyRequest.getNewPassword();
        bb.put( ( byte ) PasswordModifyRequestConstants.NEW_PASSWORD_TAG );
        bb.put( TLV.getBytes( newPassword.length ) );
        bb.put( newPassword );
    }

    return bb;
}
</code></pre>
<p>and the <em>computeLength</em> method is :</p>
<pre><code>:::Java
/**
 * Compute the PasswordModifyRequest extended operation length
 * &lt;pre&gt;
 * 0x30 L1 
 *   | 
 *  [+-- 0x80 L2 userIdentity] 
 *  [+-- 0x81 L3 oldPassword] 
 *  [+-- 0x82 L4 newPassword] 
 * &lt;/pre&gt;
 */
/* No qualifier */int computeLengthInternal()
{
    requestLength = 0;

    if ( passwordModifyRequest.getUserIdentity() != null )
    {
        int len = passwordModifyRequest.getUserIdentity().length;
        requestLength = 1 + TLV.getNbBytes( len ) + len;
    }

    if ( passwordModifyRequest.getOldPassword() != null )
    {
        int len = passwordModifyRequest.getOldPassword().length;
        requestLength += 1 + TLV.getNbBytes( len ) + len;
    }

    if ( passwordModifyRequest.getNewPassword() != null )
    {
        int len = passwordModifyRequest.getNewPassword().length;
        requestLength += 1 + TLV.getNbBytes( len ) + len;
    }

    return 1 + TLV.getNbBytes( requestLength ) + requestLength;
}
</code></pre>
<h2 id="adding-a-new-extended-operation">Adding a new Extended operation</h2>
<p>We will show how to add a new extended operation in the <strong>LDAP API</strong>. The added operation is the <em>startTransaction</em> operation, described in <a href="https://tools.ietf.org/html/rfc5805">RFC 5805</a>.</p>
<p>The <em>startTransactionRequest</em> has a <em>requestName</em> containing <strong>1.3.6.1.1.21.1</strong>, and no <em>requestValue</em>.
The <em>startTransactionResponse</em> has no <em>responseName</em> and a <em>responseValue</em> containing an opaque transaction identifier (ie, it does not need to be decoced).</p>
<p>We first need to declare an interface and implementation for each of those two operations. Those four elements are declared in the <em><coec-api></em> module (in <em>/ldap/extras/codec-api</em>), and in the <em>org.apache.directory.api.ldap.extras.extended.startTransaction</em> package, beside the other extended operations :</p>
<pre><code>:::Java
package org.apache.directory.api.ldap.extras.extended.startTransaction;


import org.apache.directory.api.ldap.model.message.ExtendedRequest;


/**
 * The TransactionRequest interface. This is for the RFC 5805 Start Transaction Request,
 * which grammar is :
 * &lt;pre&gt;
 * ExtendedRequest ::= [APPLICATION 23] SEQUENCE {
 *              requestName      [0] LDAPOID,
 *              requestValue     [1] OCTET STRING OPTIONAL }
 * &lt;/pre&gt;
 * 
 * where 'requestName' is 1.3.6.1.1.21.1 and requestValue is absent.
 *
 * @author &lt;a href=&quot;mailto:dev@directory.apache.org&quot;&gt;Apache Directory Project&lt;/a&gt;
 */
public interface StartTransactionRequest extends ExtendedRequest
{
    /** The OID for the Transaction extended operation request. */
    String EXTENSION_OID = &quot;1.3.6.1.1.21.1&quot;;
}
</code></pre>
<p>The request interface defines noting but the <em>OID</em>, as we don&rsquo;t have any payload.</p>
<p>Here is the implementation :</p>
<pre><code>:::Java
package org.apache.directory.api.ldap.extras.extended.startTransaction;


import org.apache.directory.api.ldap.model.message.AbstractExtendedRequest;


/**
 * Implement the extended Start Transaction Request as described in RFC 5805.
 * 
 * It's grammar is :
 * 
 * &lt;pre&gt;
 * ExtendedRequest ::= [APPLICATION 23] SEQUENCE {
 *              requestName      [0] LDAPOID,
 *              requestValue     [1] OCTET STRING OPTIONAL }
 * &lt;/pre&gt;
 * 
 * where 'requestName' is 1.3.6.1.1.21.1 and requestValue is absent.
 *
 * @author &lt;a href=&quot;mailto:dev@directory.apache.org&quot;&gt;Apache Directory Project&lt;/a&gt;
 */
public class StartTransactionRequestImpl extends AbstractExtendedRequest implements StartTransactionRequest
{
    /**
     * Creates a new instance of StartTransactionRequestImpl.
     *
     * @param messageId the message id
     */
    public StartTransactionRequestImpl( int messageId )
    {
        super( messageId );
        setRequestName( EXTENSION_OID );
    }


    /**
     * Creates a new instance of StartTransactionRequestImpl.
     */
    public StartTransactionRequestImpl()
    {
        setRequestName( EXTENSION_OID );
    }


    /**
     * {@inheritDoc}
     */
    @Override
    public StartTransactionResponse getResultResponse()
    {
        if ( getResponse() == null )
        {
            setResponse( new StartTransactionResponseImpl() );
        }

        return ( StartTransactionResponse ) getResponse();
    }
}
</code></pre>
<p>We just implement the method that returns the associated response.</p>
<p>Now for the response, which has an opaque value, here is the interface :</p>
<pre><code>:::Java
package org.apache.directory.api.ldap.extras.extended.startTransaction;


import org.apache.directory.api.ldap.model.message.ExtendedResponse;


/**
 * The interface for Start Transaction Extended Response. It's described in RFC 5805 :
 * 
 * &lt;pre&gt;
 * ExtendedResponse ::= [APPLICATION 24] SEQUENCE {
 *            COMPONENTS OF LDAPResult,
 *            responseName     [10] LDAPOID OPTIONAL,
 *            responseValue    [11] OCTET STRING OPTIONAL }
 * &lt;/pre&gt;
 * 
 * where the responseName is not present, and the responseValue contain
 * a transaction identifier when the result is SUCCESS.
 * 
 * @author &lt;a href=&quot;mailto:dev@directory.apache.org&quot;&gt;Apache Directory Project&lt;/a&gt;
 */
public interface StartTransactionResponse extends ExtendedResponse
{
    /** The OID for the Start Transaction extended operation response. */
    String EXTENSION_OID = StartTransactionRequest.EXTENSION_OID;
    
    
    /**
     * @return The transaction ID if success
     */
    byte[] getTransactionId();
}
</code></pre>
<p>As the response value is opaque, we return it as a <em>byte[]</em>.</p>
<p>Here is the implementation :</p>
<pre><code>:::Java
package org.apache.directory.api.ldap.extras.extended.startTransaction;


import org.apache.directory.api.i18n.I18n;
import org.apache.directory.api.ldap.model.message.ExtendedResponseImpl;
import org.apache.directory.api.ldap.model.message.ResultCodeEnum;
import org.apache.directory.api.util.Strings;


/**
 * The interface for Start Transaction Extended Response. It's described in RFC 5805 :
 * 
 * &lt;pre&gt;
 * ExtendedResponse ::= [APPLICATION 24] SEQUENCE {
 *            COMPONENTS OF LDAPResult,
 *            responseName     [10] LDAPOID OPTIONAL,
 *            responseValue    [11] OCTET STRING OPTIONAL }
 * &lt;/pre&gt;
 * 
 * where the responseName is not present, and the responseValue contain
 * a transaction identifier when the result is SUCCESS.
 * 
 *
 * @author &lt;a href=&quot;mailto:dev@directory.apache.org&quot;&gt;Apache Directory Project&lt;/a&gt;
 */
public class StartTransactionResponseImpl extends ExtendedResponseImpl implements StartTransactionResponse
{
    /** The transaction ID if the request was successful */
    private byte[] transactionId;
    
    /**
     * Create a new StartTransactionResponseImpl object
     * 
     * @param messageId The messageId
     * @param rcode the result code
     * @param transactionId The transaction ID 
     */
    public StartTransactionResponseImpl( int messageId, ResultCodeEnum resultCode, byte[] transactionId )
    {
        super( messageId );

        switch ( resultCode )
        {
            case SUCCESS:
                this.transactionId = Strings.copy( transactionId );
                // pass through ...
            case CANCELED:
            case CANNOT_CANCEL:
            case NO_SUCH_OPERATION:
            case TOO_LATE:
                break;

            default:
                throw new IllegalArgumentException( I18n.err( I18n.ERR_04166, ResultCodeEnum.SUCCESS,
                    ResultCodeEnum.OPERATIONS_ERROR, ResultCodeEnum.INSUFFICIENT_ACCESS_RIGHTS ) );
        }

        super.getLdapResult().setMatchedDn( null );
        super.getLdapResult().setResultCode( resultCode );
    }


    /**
     * Create a new StartTransactionResponseImpl instance
     * 
     * @param messageId The request's messageId
     * @param transactionId The transaction ID 
     */
    public StartTransactionResponseImpl( int messageId, byte[] transactionId )
    {
        super( messageId );
        super.getLdapResult().setMatchedDn( null );
        super.getLdapResult().setResultCode( ResultCodeEnum.SUCCESS );
        this.transactionId = Strings.copy( transactionId );
    }


    /**
     * Create a new StartTransactionResponseImpl instance
     * 
     * @param transactionId The transaction ID 
     */
    public StartTransactionResponseImpl( byte[] transactionId )
    {
        super( StartTransactionRequest.EXTENSION_OID );
        super.getLdapResult().setMatchedDn( null );
        super.getLdapResult().setResultCode( ResultCodeEnum.SUCCESS );
        this.transactionId = Strings.copy( transactionId );
    }


    /**
     * Create a new StartTransactionResponseImpl instance
     */
    public StartTransactionResponseImpl()
    {
        super( StartTransactionRequest.EXTENSION_OID );
        super.getLdapResult().setMatchedDn( null );
        super.getLdapResult().setResultCode( ResultCodeEnum.UNWILLING_TO_PERFORM );
    }


    /**
     * Gets the OID uniquely identifying this extended response (a.k.a. its
     * name). It's a null value for the Cancel response
     * 
     * @return the OID of the extended response type.
     */
    @Override
    public String getResponseName()
    {
        return &quot;&quot;;
    }


    /**
     * {@inheritDoc}
     */
    @Override
    public int hashCode()
    {
        int hash = 37;
        
        if ( transactionId != null )
        {
            for ( byte b : transactionId )
            {
                hash += hash * 17 + b;
            }
        }
        
        hash = hash * 17 + getClass().getName().hashCode();

        return hash;
    }


    /**
     * @see Object#equals(Object)
     */
    @Override
    public boolean equals( Object obj )
    {
        if ( obj == this )
        {
            return true;
        }

        if ( !( obj instanceof StartTransactionResponseImpl ) )
        {
            return false;
        }
        
        return Arrays.equals( transactionId, ( ( StartTransactionResponseImpl ) obj ).transactionId );
    }
    
    
    /**
     * {@inheritDoc}
     */
    @Override
    public byte[] getTransactionId()
    {
        return Strings.copy( transactionId );
    }
    
    
    /**
     * {@inheritDoc}
     */
    public void setTransactionId( byte[] transactionId )
    {
        this.transactionId = Strings.copy( transactionId );
    }
}
</code></pre>
<p>There is nothing special in this implementation, we just make it so the <em>transactionId</em> bytes are copied to be sure they can&rsquo;t be altered from the outside. Basically, the payload is transfered pristine into the instance.</p>
<p>Now that we have the interfaces and implementations, we need to add the decorators and the factory. The factory is used to initialize the <strong>API</strong> with the list of available extended operaiton at startup, as a mean to make the <strong>API</strong> extensible. It creates request and response, and the associated decorator.</p>
<p>Here is the factory code, declared in the <em><extra-codec></em> module :</p>
<pre><code>:::Java
package org.apache.directory.api.ldap.extras.extended.ads_impl.startTransaction;


import org.apache.directory.api.asn1.DecoderException;
import org.apache.directory.api.ldap.codec.api.ExtendedOperationFactory;
import org.apache.directory.api.ldap.codec.api.LdapApiService;
import org.apache.directory.api.ldap.extras.extended.cancel.CancelRequest;
import org.apache.directory.api.ldap.extras.extended.startTransaction.StartTransactionRequest;
import org.apache.directory.api.ldap.extras.extended.startTransaction.StartTransactionRequestImpl;
import org.apache.directory.api.ldap.extras.extended.startTransaction.StartTransactionResponse;
import org.apache.directory.api.ldap.extras.extended.startTransaction.StartTransactionResponseImpl;
import org.apache.directory.api.ldap.model.message.ExtendedRequest;
import org.apache.directory.api.ldap.model.message.ExtendedResponse;


/**
 * An {@link ExtendedOperationFactory} for creating cancel extended request response 
 * pairs.
 *
 * @author &lt;a href=&quot;mailto:dev@directory.apache.org&quot;&gt;Apache Directory Project&lt;/a&gt;
 */
public class StartTransactionFactory implements ExtendedOperationFactory
{
    private LdapApiService codec;


    /**
     * Creates a new instance of CancelFactory.
     *
     * @param codec The codec for this factory.
     */
    public StartTransactionFactory( LdapApiService codec )
    {
        this.codec = codec;
    }


    /**
     * {@inheritDoc}
     */
    @Override
    public String getOid()
    {
        return CancelRequest.EXTENSION_OID;
    }


    /**
     * {@inheritDoc}
     */
    @Override
    public StartTransactionResponse newResponse( byte[] encodedValue ) throws DecoderException
    {
        StartTransactionResponseDecorator response = new StartTransactionResponseDecorator( codec, new StartTransactionResponseImpl() );
        response.setResponseValue( encodedValue );

        return response;
    }


    /**
     * {@inheritDoc}
     */
    @Override
    public StartTransactionRequest newRequest( byte[] value )
    {
        return new StartTransactionRequestDecorator( codec, new StartTransactionRequestImpl() );
    }


    /**
     * {@inheritDoc}
     */
    @Override
    public StartTransactionRequestDecorator decorate( ExtendedRequest modelRequest )
    {
        if ( modelRequest instanceof StartTransactionRequestDecorator )
        {
            return ( StartTransactionRequestDecorator ) modelRequest;
        }

        return new StartTransactionRequestDecorator( codec, null );
    }


    /**
     * {@inheritDoc}
     */
    @Override
    public StartTransactionResponseDecorator decorate( ExtendedResponse decoratedMessage )
    {
        if ( decoratedMessage instanceof StartTransactionResponseDecorator )
        {
            return ( StartTransactionResponseDecorator ) decoratedMessage;
        }

        return new StartTransactionResponseDecorator( codec, null );
    }
}
</code></pre>
<p>The decorator are very simple : they just encapsulate the requets or response instance. It&rsquo;s because encoding or decoding is non existant for this operation. Decorators are declared in the <em><extra-codec></em> module.</p>
<p>Here is teh code for both those decorators :</p>
<pre><code>:::Java
package org.apache.directory.api.ldap.extras.extended.ads_impl.startTransaction;


import org.apache.directory.api.ldap.codec.api.ExtendedRequestDecorator;
import org.apache.directory.api.ldap.codec.api.LdapApiService;
import org.apache.directory.api.ldap.extras.extended.startTransaction.StartTransactionRequest;
import org.apache.directory.api.ldap.extras.extended.startTransaction.StartTransactionResponse;


/**
 * A Decorator for startTransaction request.
 *
 * @author &lt;a href=&quot;mailto:dev@directory.apache.org&quot;&gt;Apache Directory Project&lt;/a&gt;
 */
public class StartTransactionRequestDecorator extends ExtendedRequestDecorator&lt;StartTransactionRequest&gt; implements
    StartTransactionRequest
{
    /** The internal startTransaction request */
    private StartTransactionRequest startTransactionRequest;


    /**
     * Creates a new instance of StartTransactionRequestDecorator.
     * 
     * @param codec The LDAP Service to use
     * @param decoratedMessage The canceled request
     */
    public StartTransactionRequestDecorator( LdapApiService codec, StartTransactionRequest decoratedMessage )
    {
        super( codec, decoratedMessage );
        startTransactionRequest = decoratedMessage;
    }


    /**
     * {@inheritDoc}
     */
    @Override
    public StartTransactionResponse getResultResponse()
    {
        return ( StartTransactionResponse ) startTransactionRequest.getResultResponse();
    }
}
</code></pre>
<p>and for the response :</p>
<pre><code>:::Java
package org.apache.directory.api.ldap.extras.extended.ads_impl.startTransaction;


import org.apache.directory.api.ldap.codec.api.ExtendedResponseDecorator;
import org.apache.directory.api.ldap.codec.api.LdapApiService;
import org.apache.directory.api.ldap.extras.extended.startTransaction.StartTransactionResponse;
import org.apache.directory.api.util.Strings;


/**
 * A Decorator for CancelResponses.
 *
 * @author &lt;a href=&quot;mailto:dev@directory.apache.org&quot;&gt;Apache Directory Project&lt;/a&gt;
 */
public class StartTransactionResponseDecorator extends ExtendedResponseDecorator&lt;StartTransactionResponse&gt; implements StartTransactionResponse
{
    /** The startTransaction response */
    private StartTransactionResponse startTransactionResponse;

    /**
     * Creates a new instance of CancelResponseDecorator.
     *
     * @param codec The LDAP service instance
     * @param decoratedMessage The decorated message
     */
    public StartTransactionResponseDecorator( LdapApiService codec, StartTransactionResponse decoratedMessage )
    {
        super( codec, decoratedMessage );
        startTransactionResponse = decoratedMessage;
    }


    /**
     * {@inheritDoc}
     */
    @Override
    public void setResponseValue( byte[] responseValue )
    {
        this.responseValue = Strings.copy( responseValue );
    }


    /**
     * {@inheritDoc}
     */
    @Override
    public byte[] getTransactionId()
    {
        return startTransactionResponse.getTransactionId();
    }
}
</code></pre>
<p>The last step is to declare the extended operation in the <strong>LDAP API</strong> initialization and <strong>OSGi</strong>. There are two places we have to declare the factory :</p>
<ul>
<li><em>CodecFactoryUtil</em> class, in the <em>&lt;ldap/codec/standalone&gt;</em> module</li>
<li><em>ExtrasBundleActivator</em> class, in the <em>&lt;ldap/extras/codec&gt;</em> module</li>
</ul>
<p>Here is the added code in the <em>CodecFactoryUtil</em> class :</p>
<pre><code>:::Java
...
import org.apache.directory.api.ldap.extras.extended.ads_impl.startTls.StartTlsFactory;
import org.apache.directory.api.ldap.extras.extended.ads_impl.startTransaction.StartTransactionFactory;
...

/**
 * A utility class for adding Codec and extended operation factories.
 *
 * @author &lt;a href=&quot;mailto:dev@directory.apache.org&quot;&gt;Apache Directory Project&lt;/a&gt;
 */
public final class CodecFactoryUtil
{
    ...
    public static void loadStockExtendedOperations(
        Map&lt;String, ExtendedOperationFactory&gt; extendendOperationsFactories, LdapApiService apiService )
    {
        ...

        StartTlsFactory startTlsFactory = new StartTlsFactory( apiService );
        extendendOperationsFactories.put( startTlsFactory.getOid(), startTlsFactory );
        LOG.info( &quot;Registered pre-bundled extended operation factory: {}&quot;, startTlsFactory.getOid() );

        StartTransactionFactory startTransactionFactory = new StartTransactionFactory( apiService );
        extendendOperationsFactories.put( startTransactionFactory.getOid(), startTransactionFactory );
        LOG.info( &quot;Registered pre-bundled extended operation factory: {}&quot;, startTransactionFactory.getOid() );
        ...
    }
}
</code></pre>
<p>We just need to instanciate the factory, and to add it to the map of supported extended operations.</p>
<p>And the added code for the <em>ExtrasBundleActivator</em> class :</p>
<pre><code>:::Java
...
import org.apache.directory.api.ldap.extras.extended.ads_impl.startTls.StartTlsFactory;
import org.apache.directory.api.ldap.extras.extended.ads_impl.startTransaction.StartTransactionFactory;
...
import org.apache.directory.api.ldap.extras.extended.startTls.StartTlsRequest;
import org.apache.directory.api.ldap.extras.extended.startTransaction.StartTransactionRequest;
...

/**
 * A BundleActivator for the ldap codec extras extension: extra ApacheDS and 
 * Apache Directory Studio specific controls and extended operations. 
 *
 * @author &lt;a href=&quot;mailto:dev@directory.apache.org&quot;&gt;Apache Directory Project&lt;/a&gt;
 */
public class ExtrasBundleActivator implements BundleActivator
{
    ...
    /**
     * Registers all the extras extended operations present in this control pack.
     *
     * @param codec The codec service.
     */
    private void registerExtrasExtendedOps( LdapApiService codec )
    {
        // --------------------------------------------------------------------
        // Register Extended Request Factories
        // --------------------------------------------------------------------
        ...

        StartTlsFactory startTlsFactory = new StartTlsFactory( codec );
        codec.registerExtendedRequest( startTlsFactory );

        StartTransactionFactory startTransactionFactory = new StartTransactionFactory( codec );
        codec.registerExtendedRequest( startTransactionFactory );
        ...
    }


    private void unregisterExtrasExtendedOps( LdapApiService codec )
    {
        ...
        codec.unregisterExtendedRequest( StartTlsRequest.EXTENSION_OID );
        codec.unregisterExtendedRequest( StartTransactionRequest.EXTENSION_OID );
        ...
    }
}
</code></pre>
<p>We also have to export the package for it to be visible when using <strong>OSGi</strong>. This is done by modifying some <em>pom.xml</em> files.</p>
<p><em>&lt;ldap/extras/codec&gt;</em> module <em>pom.xml</em> file :</p>
<pre><code>:::XML
...
&lt;configuration&gt;
  &lt;manifestLocation&gt;META-INF&lt;/manifestLocation&gt;
  &lt;instructions&gt;
    &lt;Bundle-SymbolicName&gt;${project.groupId}.ldap.extras.codec&lt;/Bundle-SymbolicName&gt;
    &lt;Export-Package&gt;
        {local-packages};version=${project.version};-noimport:=true
    &lt;/Export-Package&gt;
    &lt;Export-Package&gt;
      ...
      org.apache.directory.api.ldap.extras.extended.ads_impl.startTls;version=${project.version};-noimport:=true,
      org.apache.directory.api.ldap.extras.extended.ads_impl.startTransaction;version=${project.version};-noimport:=true,
      ...
    &lt;/Export-Package&gt;
    &lt;Import-Package&gt;
      ...
      org.apache.directory.api.ldap.extras.extended.startTls;version=${project.version},
      org.apache.directory.api.ldap.extras.extended.startTransaction;version=${project.version},
      ...
    &lt;/Import-Package&gt;
</code></pre>
<p><em>&lt;ldap/extras/codec-api&gt;</em> module <em>pom.xml</em> file :</p>
<pre><code>:::XML
...
&lt;configuration&gt;
  &lt;manifestLocation&gt;META-INF&lt;/manifestLocation&gt;
  &lt;instructions&gt;
    &lt;Bundle-SymbolicName&gt;${project.groupId}.ldap.extras.codec.api&lt;/Bundle-SymbolicName&gt;
    &lt;Export-Package&gt;
      ...
      org.apache.directory.api.ldap.extras.extended.startTls;version=${project.version};-noimport:=true,
      org.apache.directory.api.ldap.extras.extended.startTransaction;version=${project.version};-noimport:=true,
      ...
    &lt;/Export-Package&gt;
</code></pre>
<h1 id="a-more-complex-example">A more complex example</h1>
<p>Wealso have to add the <em>EndTransactionRequest</em> and <em>endTransactionResponse</em> extended opertions. We will focus on the response, which is more complex that the request.</p>
<p>The <em>EndTransactionResponse</em> value follows this ASN.1 description :</p>
<pre><code>txnEndRes ::= SEQUENCE {
    messageID MessageID OPTIONAL,
         -- msgid associated with non-success resultCode
    updatesControls SEQUENCE OF updateControl SEQUENCE {
         messageID MessageID,
              -- msgid associated with controls
         controls  Controls
    } OPTIONAL
}
</code></pre>
<p>Here, <a href="https://tools.ietf.org/html/rfc5805">RFC 5805</a> gives some information about the semantic of this grammar :</p>
<ul>
<li>we can either have a message ID, if the transaction was a failure</li>
<li>or have a list of <em>UpdateControls</em> structure if we have had a success, with some controls having to be returned</li>
<li>or we simply have nothing and then the full value is simply absent.</li>
</ul>
<p><em>Controls</em> is a list of <em>Control</em> as defined in <a href="https://tools.ietf.org/html/rfc4511#section-4.1.11">RFC 4511</a>, with the following ASN.1 description :</p>
<pre><code>Controls ::= SEQUENCE OF control Control

Control ::= SEQUENCE {
         controlType             LDAPOID,
         criticality             BOOLEAN DEFAULT FALSE,
         controlValue            OCTET STRING OPTIONAL }
</code></pre>
<p>So we may have many <em>updateControls</em> and for each one of them, one to many <em>controls</em>. We will need to define a state machine to decode those two ASN/1 description.</p>
<p>First, let&rsquo;s see what is the state machine for the <em>txnEndRes</em> type and the <em>controls</em> type :</p>
<p><img src="images/EndTransactionResponse.png" alt="Extended Operations state machine"></p>
<p>The transitions from one step to the other is based on the BER encoded tag :</p>
<ul>
<li>0x30 for SEQUENCE</li>
<li>0x04 for OCTET STRING</li>
<li>0x01 for BOOLEAN</li>
<li>0x02 for INTEGER</li>
</ul>
<p>Note that some deep knowledge on ASN.1 is required to encode or decode some element.</p>
<p>Here, we will need two state machines to decode an <em>EndTransactionResponse</em> message :</p>
<ul>
<li>one for the response value</li>
<li>one for the embedded controls</li>
</ul>
<p>Hopefully, we can reuse the <em>LdapMessage</em> <em>Control</em> grammar (at least the logic)</p>
<p>So we need to code the following interfaces and classes :</p>
<ul>
<li>A container</li>
<li>A Factory</li>
<li>A Grammar (actually 2)</li>
<li>A list of states (StatesEnum)</li>
<li>A decorator</li>
<li>A decoder</li>
<li>An interface</li>
<li>An implementation</li>
</ul>
<p>The interface, implementation, factory, container and decoder are not really complex, and follow the same logic that what we shown in teh previous example.</p>
<p>The list of states is just an <em>enum</em> that describes all the states shown in the state machine exposed before :</p>
<ul>
<li>Global SEQUENCE</li>
<li>MessageId</li>
<li>UpdateControls SEQUENCE</li>
<li>UpdateControl SEQUENCE</li>
<li>UpdateControl messageId</li>
<li>Controls</li>
<li>start and end states</li>
</ul>
<p>We can see we don&rsquo;t have any state associated with the <em>Control</em> decoding : it&rsquo;s handled by another codec.</p>
<p>Here is the <em>enum</em> :</p>
<pre><code>:::Java
package org.apache.directory.api.ldap.extras.extended.ads_impl.endTransaction;


import org.apache.directory.api.asn1.ber.grammar.States;


/**
 * This class store the EndTransactionResponse's grammar constants. It is also used
 * for debugging purposes.
 * 
 * @author &lt;a href=&quot;mailto:dev@directory.apache.org&quot;&gt;Apache Directory Project&lt;/a&gt;
 */
public enum EndTransactionResponseStatesEnum implements States
{
    /** The END_STATE */
    END_STATE,
    
    /** start state*/
    START_STATE,
    
    /** The initial SEQUENCE */
    END_TRANSACTION_SEQUENCE_STATE,
    
    /** The failed message ID */
    FAILED_MESSAGE_ID_STATE,
    
    /** The update controls SEQ */
    UPDATE_CONTROLS_SEQ_STATE,
    
    /** The update control SEQ */
    UPDATE_CONTROL_SEQ_STATE,
    
    /** THe control's message ID state */
    CONTROL_MESSAGE_ID_STATE,
    
    /** The control's state */
    CONTROLS_STATE,

    /** Last state */
    LAST_STATE;


    /**
     * Get the grammar name
     * 
     * @return The grammar name
     */
    public String getGrammarName()
    {
        return &quot;END_TRANSACTION_RESPONSE_GRAMMER&quot;;
    }


    /**
     * Get the string representing the state
     * 
     * @param state The state number
     * @return The String representing the state
     */
    public String getState( int state )
    {
        return ( state == END_STATE.ordinal() ) ? &quot;END_TRANSACTION_RESPONSE_GRAMMER&quot; : name();
    }


    /**
     * {@inheritDoc}
     */
    @Override
    public boolean isEndState()
    {
        return this == END_STATE;
    }


    /**
     * {@inheritDoc}
     */
    @Override
    public EndTransactionResponseStatesEnum getStartState()
    {
        return START_STATE;
    }
}
</code></pre>
<p>We can now define transitions between states, accordingly to the grammar semantic :</p>
<table>
<thead>
<tr>
<th>Initial state</th>
<th>Tag</th>
<th>Final state</th>
<th>action</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>START</td>
<td>SEQUENCE</td>
<td>END_TRANSACTION_SEQUENCE</td>
<td>Initialize the data structure holding the result</td>
<td></td>
</tr>
<tr>
<td>END_TRANSACTION_SEQUENCE</td>
<td>INTEGER</td>
<td>FAILED_MESSAGE_ID</td>
<td>Store the failed message ID</td>
<td></td>
</tr>
<tr>
<td>FAILED_MESSAGE_ID</td>
<td>none</td>
<td>END</td>
<td>The value has been fully decode, get out</td>
<td></td>
</tr>
<tr>
<td>END_TRANSACTION_SEQUENCE</td>
<td>SEQUENCE</td>
<td>UPDATE_CONTROLS_SEQ</td>
<td>Create a list of <em>UpdateControls</em>, store it in the response</td>
<td></td>
</tr>
<tr>
<td>UPDATE_CONTROLS_SEQ</td>
<td>SEQUENCE</td>
<td>UPDATE_CONTROL_SEQ</td>
<td>Create a <em>UpdateControls</em> instance, store it in the list</td>
<td></td>
</tr>
<tr>
<td>UPDATE_CONTROL_SEQ</td>
<td>INTEGER</td>
<td>CONTROL_MESSAGE_ID</td>
<td>Store the message ID in the <em>updateControls</em> instance</td>
<td></td>
</tr>
<tr>
<td>CONTROL_MESSAGE_ID</td>
<td>SEQUENCE</td>
<td>CONTROLS</td>
<td>Grab the full value, call teh Controls decoder, store the result in the <em>updateControls</em> instance</td>
<td></td>
</tr>
<tr>
<td>CONTROLS</td>
<td>SEQUENCE</td>
<td>UPDATE_CONTROL_SEQ</td>
<td>Create a <em>UpdateControls</em> instance, store it in the list</td>
<td></td>
</tr>
<tr>
<td>CONTROLS</td>
<td>none</td>
<td>END</td>
<td>The decoding is over, we can quit</td>
<td></td>
</tr>
</tbody>
</table>
<p>Each of those transitions will have an associated action. They are added in a <em>Grammar</em> class. A <em>GrammarTransition</em> is created and takes 3 or 4 parameters :</p>
<ul>
<li>An initial state (&lsquo;from&rsquo;)</li>
<li>A final state (&lsquo;to&rsquo;)</li>
<li>A tag</li>
<li>An optional action to execute</li>
</ul>
<p>Each state may have many transitions going to many different states, but each transition must use a different tag.</p>
<p>Here is an example of transition :</p>
<pre><code>:::Java
/**
 * Transition from Sequence to messageId
 *
 * txnEndReq ::= SEQUENCE {
 *         messageID MessageID OPTIONAL,
 *              -- msgid associated with non-success resultCode
 *     ...
 *     
 * Set the messageId into the EndTransactionResponse instance, if it's not SUCCESS.
 */
super.transitions[EndTransactionResponseStatesEnum.END_TRANSACTION_SEQUENCE_STATE.ordinal()][UniversalTag.INTEGER.getValue()] =
    new GrammarTransition&lt;EndTransactionResponseContainer&gt;(
        EndTransactionResponseStatesEnum.END_TRANSACTION_SEQUENCE_STATE,
        EndTransactionResponseStatesEnum.FAILED_MESSAGE_ID_STATE,
        UniversalTag.INTEGER.getValue(),
        new GrammarAction&lt;EndTransactionResponseContainer&gt;( &quot;Set EndTransactionResponse failed MessageID&quot; )
        {
            public void action( EndTransactionResponseContainer container ) throws DecoderException
            {
                BerValue value = container.getCurrentTLV().getValue();

                try
                {
                    int failedMessageId = IntegerDecoder.parse( value );
                    
                    if ( failedMessageId &gt; 0 )
                    {
                        container.getEndTransactionResponse().setFailedMessageId( failedMessageId );
                    }

                    // We may have nothing left
                    container.setGrammarEndAllowed( true );
                }
                catch ( IntegerDecoderException ide )
                {
                    LOG.error( I18n
                        .err( I18n.ERR_04490_BAD_END_TRANSACTION_COMMIT, Strings.dumpBytes( value.getData() ), ide.getMessage() ) );

                    // This will generate a PROTOCOL_ERROR
                    throw new DecoderException( ide.getMessage(), ide );
                }
            }
        } );
</code></pre>
<p>In this example, we have a transition from a <strong>END_TRANSACTION_SEQUENCE_STATE</strong> state to a <strong>FAILED_MESSAGE_ID</strong> state, which is triggered by an <strong>INTEGER</strong> tag. The executed action is created immediately, but it could have been a separated class.</p>


            
    <div class="nav">
        <div class="nav_prev">
            
                
                <a href="13-controls.html">13 - Controls</a>
            
        </div>
        <div class="nav_up">
            
                
                <a href="../internal-design-guide.html">Internal Design Guide</a>
            
        </div>
        <div class="nav_next">
            
                
                <a href="15-ldif.html">15 - LDIF</a>
            
        </div>
        <div class="clearfix"></div>
    </div>


        </div>
        <div id="endContent"></div>
    </div>

    <div id="footer">
    &copy; 2003-2020, <a href="http://www.apache.org">The Apache Software Foundation</a> - <a href="/privacy-policy.html">Privacy Policy</a><br />
    Apache Directory, ApacheDS, Apache Directory Server, Apache Directory Studio, Apache LDAP API, Apache Triplesec,
    Triplesec, Apache Mavibot, Mavibot, Apache eSCIMo, eSCIMo, Apache SCIMple, SCIMple,Fortress, Apache Fortress, EnMasse,
    Apache EnMasse, Apache Kerby, Kerby, Apache, the Apache feather logo, and the Apache Directory project logos are
    trademarks of The Apache Software Foundation.
</div>

</div>

</body>

</html>
