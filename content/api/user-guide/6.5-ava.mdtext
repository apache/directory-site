Title: 6.5 - Ava
NavPrev: 6.4-attribute-type.html
NavPrevText: 6.4 - AttributeType
NavUp: 6-ldap-data-structures.html
NavUpText: 6 - LDAP data structures
NavNext: 6.6-control.html
NavNextText: 6.6 - Control
Notice: Licensed to the Apache Software Foundation (ASF) under one
    or more contributor license agreements.  See the NOTICE file
    distributed with this work for additional information
    regarding copyright ownership.  The ASF licenses this file
    to you under the Apache License, Version 2.0 (the
    "License"); you may not use this file except in compliance
    with the License.  You may obtain a copy of the License at
    .
    http://www.apache.org/licenses/LICENSE-2.0
    .
    Unless required by applicable law or agreed to in writing,
    software distributed under the License is distributed on an
    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, either express or implied.  See the License for the
    specific language governing permissions and limitations
    under the License.

# 6.5 - Ava

An _Ava_ is used to store an _Attribute_ value associated to an _AttributeType_. 

It describes a container holding an _AttributeType_ associated with a _Value_ in a _Rdn_. An example would be :

    :::Java
    dc=example

where 'dc' is the _AttributeType_ and 'example' the associated value.

The value can be a binary or a String value, depending on the _AttributeType_.

We can create schema aware _Ava_, or just plain _Ava_. Having a schema aware _Ava_ allows further controls to be made on the value we inject : its syntax will be checked against the _AttributeType_ syntax.

Most of the time, one will not have to create or manipulate an _Ava_, as it's an internal element of a _Rdn_.

_Ava_ is also a _Externalizable_ class.

_Ava_ instances are immutable.


## Usage

As for the _Dn_ and _Rdn_ classes, we have to hold two representation for the interned _AttributeType_ and _Value_ : the User Provided form, and the escaped form (which is used in filters). If the _AVA_ is schema aware, the escaped form will be computed, otherwise we store the user provided form instead. Let's see some examples.


### Schema Aware Ava

Here we will create an _AVA_ and check that the user provided values are preserved. The _getName()_ and _getString()_ methods will give back this user provided form, in a form that allows it to be used in a Filter.

    :::Java
    Ava atav = new Ava( schemaManager, " CommonName ", " This is    a TEST " );
    System.out.println( "toString     : '" + atav.toString() + "'" );
    System.out.println( "Escaped      : '" + atav.getEscaped() + "'" );
    System.out.println( "UserProvided : '" + atav.getName() + "'" );

will produce :

    :::Java
    toString     : ' CommonName =\ This is    a TEST\ '
    Escaped      : ' CommonName =\ This is    a TEST\ '
    UserProvided : ' CommonName =\ This is    a TEST\ '


*{+}Not Schema Aware{+}*

The biggest difference in this case is that the _AttributeType_ will not be replaced by its _Oid_, but instead by a lower cased form of the provided ID. We also escape the leading and trailing spaces in the value.

{code}
public void testAvaSimpleNorm() throws LdapException
{
    Ava atav = new Ava( null, " CommonName ", " This is    a TEST " );
    assertEquals( " CommonName = This is    a TEST ", atav.toString() );
    assertEquals( "commonname=\\ This is    a TEST\\ ", atav.getNormName() );
    assertEquals( " CommonName = This is    a TEST ", atav.getUpName() );
}
{code}