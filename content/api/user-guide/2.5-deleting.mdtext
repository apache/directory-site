Title: 2.5 - Deleting entries
NavPrev: 2.4-adding.html
NavPrevText: 2.4 - Adding entries
NavUp: 2-basic-ldap-api-usage.html
NavUpText: 2 - Basic LDAP API usage
NavNext: 2.6-modifying.html
NavNextText: 2.6 - Modifying entries
Notice: Licensed to the Apache Software Foundation (ASF) under one
    or more contributor license agreements.  See the NOTICE file
    distributed with this work for additional information
    regarding copyright ownership.  The ASF licenses this file
    to you under the Apache License, Version 2.0 (the
    "License"); you may not use this file except in compliance
    with the License.  You may obtain a copy of the License at
    .
    http://www.apache.org/licenses/LICENSE-2.0
    .
    Unless required by applicable law or agreed to in writing,
    software distributed under the License is distributed on an
    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, either express or implied.  See the License for the
    specific language governing permissions and limitations
    under the License.

# 2.5 - Deleting entries

Deleting an entry is pretty easy, it just requires the entry's _DN_. There is one important thing to understand though, if the entry has children, the operation will fail.

## Simple entry deletion

We request a deletion by providing the entry's _DN_, as in the following example:

    :::Java
    @Test
    public void testDeleteLeafNode() throws Exception
    {
        assertTrue( session.exists( "cn=child1,cn=parent,ou=system" ) );

        DeleteResponse response = connection.delete( "cn=child1,cn=parent,ou=system" );
        assertNotNull( response );
        assertEquals( ResultCodeEnum.SUCCESS, response.getLdapResult().getResultCode() );

        assertFalse( session.exists( "cn=child1,cn=parent,ou=system" ) );
    }


Trying to delete a parent node would result in an error (NOT_ALLOWED_ON_NON_LEAF) :

    :::Java
    @Test
    public void testDeleteNonLeafFailure() throws Exception
    {
        assertTrue( session.exists( "cn=parent,ou=system" ) );

        DeleteResponse response = connection.delete( "cn=parent,ou=system" );
        assertNotNull( response );
        assertEquals( ResultCodeEnum.NOT_ALLOWED_ON_NON_LEAF, response.getLdapResult().getResultCode() );

        assertTrue( session.exists( "cn=parent,ou=system" ) );
    }


## Recursive deletion of entries

Usually, you can't delete an entry and all of its children in one operation. However, some servers accept such requests if you send a delete request and a TreeDelete control. This control is a [draft](http://tools.ietf.org/html/draft-armijo-ldap-treedelete-02), which has been implemented by **Microsoft**, **OpenDS**, **OpenDJ**. It will delete all the children and the entry itself. We don't use a normal _delete()_ method, there is a specific method, _deleteTree()_. Here is an example :

    :::Java
    @Test
    public void testDeleteWithCascadeControl() throws Exception
    {
        assertTrue( session.exists( "cn=parent,ou=system" ) );


        DeleteResponse response = connection.deleteTree( "cn=parent,ou=system" );
        assertNotNull( response );
        assertEquals( ResultCodeEnum.SUCCESS, response.getLdapResult().getResultCode() );

        assertFalse( session.exists( "cn=parent,ou=system" ) );
    }


## Sending a DeleteRequest with a control

It's also possible to associate a **[Control]** with the delete request. In order to do that, you have to create a _DelRequest_ instance. In the following example, we will add the Delete Tree control (this make this call equivalent to the _deleteTree()_ method).

    :::Java
    @Test
    public void testDeleteWithControl() throws Exception
    {
        assertTrue( session.exists( "cn=parent,ou=system" ) );

        if ( connection.isControlSupported( "1.2.840.113556.1.4.805" ) )
        {
            DeleteRequest deleteRequest = new DeleteRequestImpl();
            deleteRequest.setName( new Dn( "cn=parent,ou=system" ) );
            Control deleteTreeControl = new OpaqueControl( "1.2.840.113556.1.4.805" );
            deleteRequest.addControl( deleteTreeControl );
    
            DeleteResponse deleteResponse = connection.delete( deleteRequest );
    
            assertNotNull( deleteResponse );
            assertEquals( ResultCodeEnum.SUCCESS, deleteResponse.getLdapResult().getResultCode() );
            assertFalse( session.exists( "cn=parent,ou=system" ) );
        }
    }


## Asynchronous delete

You can also decide to send an asynchronous delete request : the method will return a Future that you can check later. You have to construct a **[DeleteRequest]** instance. Here is an example :

    :::Java
    @Test
    public void testDeleteAsync() throws Exception
    {
        assertTrue( session.exists( "cn=child,cn=parent,ou=system" ) );

        DeleteRequest deleteRequest = new DeleteRequestImpl();
        deleteRequest.setName( new Dn( "cn=child,cn=parent,ou=system" ) );

        DeleteFuture deleteFuture = connection.deleteAsync( deleteRequest );

        DeleteResponse deleteResponse = deleteFuture.get( 1000, TimeUnit.MILLISECONDS );

        assertNotNull( deleteResponse );
        assertEquals( ResultCodeEnum.SUCCESS, deleteResponse.getLdapResult().getResultCode() );
        assertFalse( session.exists( "cn=child,cn=parent,ou=system" ) );
    }
