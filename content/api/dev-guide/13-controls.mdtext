Title: 13 - Controls
NavPrev: 12-cursor.html
NavPrevText: 12 - Cursor
NavUp: ../dev-guide.html
NavUpText: Developer Guide
NavNext: 14-extended-operations.html
NavNextText: 14 - Extended Operations
Notice: Licensed to the Apache Software Foundation (ASF) under one
    or more contributor license agreements.  See the NOTICE file
    distributed with this work for additional information
    regarding copyright ownership.  The ASF licenses this file
    to you under the Apache License, Version 2.0 (the
    "License"); you may not use this file except in compliance
    with the License.  You may obtain a copy of the License at
    .
    http://www.apache.org/licenses/LICENSE-2.0
    .
    Unless required by applicable law or agreed to in writing,
    software distributed under the License is distributed on an
    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, either express or implied.  See the License for the
    specific language governing permissions and limitations
    under the License.

# 13 - Controls


Controls are extension to the protocol. They are added in messages, and can contain extra information. A **Control** contains :

* an **OID**, unique to this **Control**, as an identifier
* a **Criticality** flag, which tells if the control can be ignored or not
* a value, which might be **BER** encoded 

We have 21 **Control**s declared in the **LDAP API**, and we can add more.

## Implementation

Here is teh **Control** classes and interfaces hierarchy :

![Control Hierarchy](images/controls.png)

As we can see, each _Impl_ class is coupled with a _Decorator_ class, used to process teh encoding and decoding of a **Control**

Keep in mind that **Control**s have to be sent within a message, thus be encoded or decoded when the response come back.

## Creating a new Control

The **Control** creation follows a few rules :

* It has to have a unique **OID** (this is generally the case, for **Control**s defined in RFCs)
* It has an _Interface_, a _Decorator_ and an implementation
* It must be declared

Let's see how it all works, using an example. We will add the **Transaction Specification Control**, defined in [RFC 5805(https://tools.ietf.org/html/rfc5805)], paragraphe 2.2 :

    :::Text
    2.2.  Transaction Specification Control

    A Transaction Specification Control is an LDAPControl where the
    controlType is 1.3.6.1.1.21.2, the criticality is TRUE, and the
    controlValue is a transaction identifier.  The control is appropriate
    for update requests including Add, Delete, Modify, and ModifyDN
    (Rename) requests [RFC4511], as well as the Password Modify requests
    [RFC3062].

    As discussed in Section 4, the Transaction Specification control can
    be used in conjunction with request controls appropriate for the
    update request.

The _Interface_ will just expose the _Transaction Identifier_, and store the **Control** **OID** :

    :::Java
    /**
     * The Transaction Specification control. It's defined in RFC 5805.
     * This control is sent with every update once a transaction is started.
     * It contains the Transaction ID. 
     *
     * @author <a href="mailto:dev@directory.apache.org">Apache Directory Project</a>
     */
    public interface TransactionSpecification
    {
        /** The Transaction Specification control OID */
        String OID = "1.3.6.1.1.21.2";

        /**
         * @return The transaction identifier
         */
        byte[] getIdentifier();
        
        
        /**
         * Set the transaction ID
         * @param The transaction identifier, an opaque byte array
         */
        void setIdentifier( byte[] identifier );
    }

We now need an implementation for this **Control**. It really just a matter of having an instanciable object. Note that this class exteds the _AbstractControl_ class.

Here is it :

    :::Java
    /**
     * The Transaction Specification control. It's defined in RFC 5805.
     * This control is sent with every update once a transaction is started.
     * It contains the Transaction ID. 
     *
     * @author <a href="mailto:dev@directory.apache.org">Apache Directory Project</a>
     */
    public class TransactionSpecificationImpl extends AbstractControl implements TransactionSpecification
    {
        /** The Transaction Specification identifier */
        private byte[] identifier;


        /**
         * Default constructor
         */
        public TransactionSpecificationImpl()
        {
            super( OID );
        }
        

        /**
         * {@inheritDoc}
         */
        @Override
        public byte[] getIdentifier()
        {
            return identifier;
        }
        
        
        /**
         * {@inheritDoc}
         */
        @Override
        public void setIdentifier( byte[] identifier )
        {
            // Copy the byte[]
            if ( identifier != null )
            {
                this.identifier = new byte[identifier.length];
                System.arraycopy( identifier, 0, this.identifier, 0, identifier.length );
            }
        }
        
        
        /**
         * @see Object#toString()
         */
        @Override
        public String toString()
        {
            if ( identifier != null )
            {
                return "Transaction specification ID=null";
            }
            else
            {
                return "Transaction specification ID=" + Strings.dumpBytes( identifier );
            }
        }
    }

Nothing much to say, except that we have a default constructor that use the **Control**'s **OID** and a _toString()_ method, for convenience. The _Identifier_ is printed in hex format.



### Encoding

### Decoding

## Adding a Control to the API

 

When 