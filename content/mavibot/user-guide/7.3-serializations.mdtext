Title: 7.3 - Serializations
NavUp: 7-btree-internals.html
NavUpText: 7 - Mavibot Internals
NavPrev: 7.2-physical-storage.html
NavPrevText: 7.2 - Physical storage
Notice: Licensed to the Apache Software Foundation (ASF) under one
    or more contributor license agreements.  See the NOTICE file
    distributed with this work for additional information
    regarding copyright ownership.  The ASF licenses this file
    to you under the Apache License, Version 2.0 (the
    "License"); you may not use this file except in compliance
    with the License.  You may obtain a copy of the License at
    .
    http://www.apache.org/licenses/LICENSE-2.0
    .
    Unless required by applicable law or agreed to in writing,
    software distributed under the License is distributed on an
    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, either express or implied.  See the License for the
    specific language governing permissions and limitations
    under the License.

# 7.3 - Serializations

The logical pages are serialized before being stored on physical pages. This is a process that should obviously be reversible. W will describe in this chapter how we serialize **Leaf** and **Node**.

## Leaf serialization

A **Leaf** contains some medata data, and a set of keys and values. A key can have many values, and we have as many keys as values. That being said, let's describe the internal format of a serialized leaf :

<pre>
    +----------------------------------+
    | revision (long)                  | 8 bytes
    +----------------------------------+
    | nbElems (int)                    | 4 bytes
    +----------------------------------+
    | dataSize (int)                   | 4 bytes = sum[0..nbElems]( valueLength, keyLength ) + 8 x nbElems
    +----------------------------------+
    | +------------------------------+ |
    | | valueLength[0] (int)         | | 4 bytes \
    | +------------------------------+ |           > n+4 bytes
    | | value[0] (byte[])            | | n bytes /
    | +------------------------------+ |
    | | keyLength[0] (int)           | | 4 bytes \
    | +------------------------------+ |           > n+4 bytes
    | | key[0] (byte[])              | | n bytes /
    | +------------------------------+ |
    ...                              ...
    | +------------------------------+ |
    | | valueLength[nbElems-1] (int) | | 4 bytes \
    | +------------------------------+ |           > n+4 bytes
    | | value[nbElems-1] (byte[])    | | n bytes /
    | +------------------------------+ |
    | | keyLength[nbElems-1] (int)   | | 4 bytes \
    | +------------------------------+ |           > n+4 bytes
    | | key[nbElems-1] (byte[])      | | n bytes /
    | +------------------------------+ |
    +----------------------------------+

</pre>

We keep the length of each serialized key and value just because we need to provide a complete byte[] to the key or value deserializer (ie, the exact number of bytes needed to be able to deserialize the key or the value).

The _dataSize_ value is used so that we can know how many bytes we will have to read - thus the number of physical pages to read - in order to get a full page.

## Leaf deserialization

On the other way, when we deserialize a leaf, we won't deserialize the keys and the values (it would be too expensive, if the leaf is discarded from memory immediately, when we only need to read one single key and value). We thus keep the byte[] form of each keys and each values, which will be deserialized on demand.

We use two data structures to store a key and a value :
* a _KeyHolder_ for the key
* a _ValueHolder_ for the value

### KeyHolder

### ValueHolder