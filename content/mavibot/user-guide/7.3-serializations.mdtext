Title: 7.3 - Serializations
NavUp: 7-btree-internals.html
NavUpText: 7 - Mavibot Internals
NavPrev: 7.2-physical-storage.html
NavPrevText: 7.2 - Physical storage
Notice: Licensed to the Apache Software Foundation (ASF) under one
    or more contributor license agreements.  See the NOTICE file
    distributed with this work for additional information
    regarding copyright ownership.  The ASF licenses this file
    to you under the Apache License, Version 2.0 (the
    "License"); you may not use this file except in compliance
    with the License.  You may obtain a copy of the License at
    .
    http://www.apache.org/licenses/LICENSE-2.0
    .
    Unless required by applicable law or agreed to in writing,
    software distributed under the License is distributed on an
    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, either express or implied.  See the License for the
    specific language governing permissions and limitations
    under the License.

# 7.3 - Serializations

The logical pages are serialized before being stored on physical pages. This is a process that should obviously be reversible. W will describe in this chapter how we serialize **Leaf** and **Node**.

## Leaf serialization

A **Leaf** contains some medata data, and a set of keys and values. A key can have many values, and we have as many keys as values. That being said, let's describe the internal format of a serialized leaf :

<pre>
    +----------------------------------+
    | revision (long)                  | 8 bytes
    +----------------------------------+
    | nbElems (int)                    | 4 bytes
    +----------------------------------+
    | dataSize (int)                   | 4 bytes = sum[0..nbElems]( valueLength, keyLength ) + 8 x nbElems
    +----------------------------------+
    | +------------------------------+ |
    | | valueLength[0] (int)         | | 4 bytes \
    | +------------------------------+ |           > n+4 bytes
    | | value[0] (byte[])            | | n bytes /
    | +------------------------------+ |
    | | keyLength[0] (int)           | | 4 bytes \
    | +------------------------------+ |           > n+4 bytes
    | | key[0] (byte[])              | | n bytes /
    | +------------------------------+ |
    ...                              ...
    | +------------------------------+ |
    | | valueLength[nbElems-1] (int) | | 4 bytes \
    | +------------------------------+ |           > n+4 bytes
    | | value[nbElems-1] (byte[])    | | n bytes /
    | +------------------------------+ |
    | | keyLength[nbElems-1] (int)   | | 4 bytes \
    | +------------------------------+ |           > n+4 bytes
    | | key[nbElems-1] (byte[])      | | n bytes /
    | +------------------------------+ |
    +----------------------------------+

</pre>

We keep the length of each serialized key and value just because we need to provide a complete byte[] to the key or value deserializer (ie, the exact number of bytes needed to be able to deserialize the key or the value).

The _dataSize_ value is used so that we can know how many bytes we will have to read - thus the number of physical pages to read - in order to get a full page.

## Leaf deserialization

On the other way, when we deserialize a leaf, we won't deserialize the keys and the values (it would be too expensive, if the leaf is discarded from memory immediately, when we only need to read one single key and value). We thus keep the byte[] form of each keys and each values, which will be deserialized on demand.

We use two data structures to store a key and a value :
* a _KeyHolder_ for the key
* a _ValueHolder_ for the value

### KeyHolder

The _KeyHolder_ data structure holds the key in two ways :
* serialized (raw)
* deserialized (key)

When we just read the data from disk, we don't deserialize the keys. We do that when needed.

Here is a description of this class :

<pre>
public class KeyHolder<K>
{
    /** The deserialized key */
    private K key;

    /** The ByteBuffer storing the key */
    private byte[] raw;

    /** The Key serializer */
    private ElementSerializer<K> keySerializer;
}

#### KeyHolder operations

Here is a description of the available methods in the KeyHolder class.

##### Constructors

We have two constructors for this class, one which takes a deserialized key, the other which takes a byte[].

* _KeyHolder( ElementSerializer<K> keySerializer, K key )_

Here, we need to serailize the key immediately, as we may have to flush the key to the disk. We then serialize the Key immediately and store the resulting byte[] into the _raw_ field.


* KeyHolder( ElementSerializer<K> keySerializer, byte[] raw )

Here, we just get the serialized form. We don't need to deserialize it, as the key might not be used anytime soon. We thus just update the _raw_ field, and the _key_ field remains null.

##### getKey()

This method retuns the deserialized key. If it does not exist, then we deserialize it on the fly using the _raw_ field.

##### setKey()

This method set the key. We immediately serialize it, and store the results in the _raw_ field.

##### getRaw()

Returns the _raw_ field. This method is only visible from the classes in the same package.


### ValueHolder

The _ValueHolder_ data structure will store the list of values associated with a key. As we may have more than one value, we use an internal structure for that purpose.

In some case, the number of values to store is really big, this we need to use an internal data structure that allows a quick retrieval of a value, plus we need to be able to copy a page containing such a value in an efficient way. For these reasons, we use two different internal data structures :
* an array up to a threshold
* a sub-BTree above this threshold

When we reach the threshold, the array is transformed into a BTree, and the way back if we get below this number. In order to avoid many array <-> btree transformations if we continusously add and delete a value, the array -> btree threshold is bigger than the btree -> array threshold.

<pre>
   0---1---2---...---TH-low--...--TH-high---...
   >-------------Array----------->>---BTree---... When we add new values.
                     |////////////|               These values will remain in an array or a BTree until
                                                  we reach oe of the threshold values.
   <-----Array-----<<--------BTree------------... When we delete values.
</pre>

It's important to know that the sub-BTree will hold only keys, and no values. The sub-btree Keys will be the values we have to store.

#### ValueHolder operations
The possible operations on a ValueHolder are the following :

* add( value ) : Insert a new value into the ValueHolder. If we reach the upper threshold, then the array is converted into a BTree. In any case, we inject the new value into the array or the BTree so that we keep all the value ordered (the ValueSerializer must have a _Comparator_).

As we need to compare values, they must be deserialised, so we need to do it if it's not already done (the values are not deserialiezed when the page is read from the disk). Note that it's not necessary for the sub BTree, as it's up to the sub-btree to deserialize the keys on the fly

The _add_ algorithm will thus be :

<pre>
  if the values are not yet deserialized
    then deserialize all the values
